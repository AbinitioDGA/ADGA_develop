#! /usr/bin/env python

from __future__ import print_function, division, absolute_import
import numpy as np
import h5py
import sys
import os
import scipy.linalg
import scipy.optimize


# insert w2dynamics license here
def read_hamiltonian(hkfile):
  r""" Reads a Hamiltonian f$ H_{bb'}(k) f$ from a text file.

  Expects a text file with white-space separated values in the syntax as
  generated by wannier90:  the first line is a header with three integers,
  optionally followed by '#'-prefixed comment:

      <no of k-points> <no of wannier functions> <no of bands (ignored)>

  For each k-point, there is a header line with the x, y, z coordinates of the
  k-point, followed by <nbands> rows as lines of 2*<nbands> values each, which
  are the real and imaginary part of each column.
  """
  with open(hkfile,'r') as hkdata:
    def nextline():
      line = hkdata.readline()
      return line[:line.find('#')].split()

    # parse header
    header = nextline()
    if header[0] == 'VERSION':
      nkpoints, natoms = map(int, nextline())
      lines = np.array([nextline() for _ in range(natoms)], np.int)
      nbands = np.sum(lines[:,:2])
      del lines, natoms
    elif len(header) != 3:
      header = map(int, header)
      nkpoints = header[0]
      nbands = header[1] * (header[2] + header[3])
    else:
      nkpoints, nbands, _ = map(int, header)
    del header

    # nspins is the spin dimension for H(k); G(iw), Sigma(iw) etc. will always
    # be spin-dependent
    hkdata.flush()

    # parse data
    hk = np.fromfile(hkdata, sep=" ")

  nspins = 1 # enforced by ADGA
  hk = hk.reshape(-1, 3 + 2 * nbands**2 * nspins**2)
  kpoints_file = hk.shape[0]
  if kpoints_file > nkpoints:
    raise IOError('Number of k-points do not match')

  kpoints = hk[:nkpoints, :3]

  hk = hk[:nkpoints, 3:].reshape(nkpoints, nbands, nbands, 2)
  hk = hk[...,0] + 1j * hk[...,1]
  print("Hamiltonian shape: {}".format(hk.shape))
  if not np.allclose(hk, hk.transpose(0,2,1).conj()):
    print("Hermiticity violation detected in Hk file")
  print("Hermiticity check of Hamiltonian successful.")

  return hk, kpoints, nbands

if __name__ == '__main__':
  hub2d = False

  if True:
    if len(sys.argv) != 8:
      sys.exit('Sys Argv not long enough: hkfile nkx nky nkz a b c')

    w2wfile = sys.argv[1].strip()

    nkx, nky, nkz = [int(i) for i in sys.argv[2:5]] # k-points
    a, b, c       = [float(i) for i in sys.argv[5:8]] # lattice constants

    dkx = 2*np.pi/a/nkx # distance of k-points in k-space
    dky = 2*np.pi/b/nky
    dkz = 2*np.pi/c/nky

    print('parsing: {}'.format(w2wfile))
    hk, kpoints, nbands = read_hamiltonian(w2wfile)

    if nkx*nky*nkz != hk.shape[0]:
      sys.exit('Provided directional k-points do not agree with provided hk file')


    hk.resize((nkx,nky,nkz,nbands,nbands))


    # real because diagonal part of hermitian matrix
    hkdiag = hk[...,np.arange(nbands),np.arange(nbands)].real # nkx nky nkz nbands 

    vk = np.zeros((nkx,nky,nkz,nbands,3)) # derivative

    for iband in range(nbands):
      test = np.gradient(hkdiag[:,:,:,iband], dkx, dky, dkz)
      for i in range(3):
        vk[:,:,:,iband,i] = test[i].real

    with h5py.File('HkdkFile_{}_{}_{}.hdf5'.format(nkx,nky,nkz),'w') as h5:
      h5['hk_full']    = hk
      h5['hkder_full'] = vk

    vk.resize(nkx*nky*nkz,nbands,3)
    hk.resize(nkx*nky*nkz,nbands,nbands)

    with h5py.File('HkdkFile_{}_{}_{}.hdf5'.format(nkx,nky,nkz),'a') as h5:
      h5['hk']    = hk
      h5['hkder'] = vk

    # with h5py.File('HkdkFile_{}_{}_{}.hdf5'.format(nkx,nky,nkz),'w') as h5:
    #   h5['hk']    = ek
    #   h5['hkder'] = vk

  sys.exit()

    # construct the hamiltonian derivative here ...
    # given the unit cell symmetry
    # and the lattice constants
    # calculate the intra-band derivatives
    # and save them into an hdf5 file
    # which is read by the conductivity module of ADGA

  if hub2d:
    # mostly copied from the LINRETRACE project
    nkz = 1
    nkx = nky = 72 # ek = -2t cos(kx * a) - 2t * cos(ky * a)
                 # vk = 2at sin(kx * a) + 2at * sin(ky * a)
    hopping = 1
    ndim = 2
    spacing = 1

    _kmeshx = np.linspace(0,1,nkx,endpoint=False)
    _kmeshy = np.linspace(0,1,nky,endpoint=False)
    _kmeshz = np.linspace(0,1,nkz,endpoint=False)

    ek = np.zeros((nkx, nky, nkz),     dtype=np.float64)
    vk = np.zeros((nkx, nky, nkz, 3) , dtype=np.float64)

    # [0,1) -> [0,2pi)
    # dispersion
    ek += -2. * hopping * (np.cos(_kmeshx*2*np.pi)[:,None,None] \
                        +  np.cos(_kmeshy*2*np.pi)[None,:,None] \
                        +  np.cos(_kmeshz*2*np.pi)[None,None,:])

    # dimensionality offset
    ek += 2 * hopping * (3-ndim) # to compensate for the cosine offset we get by evaluating cos(0)

    # first derivative -> velocities
    vk[...,0] += 2. * hopping * spacing * np.sin(_kmeshx*2*np.pi)[:,None,None]
    vk[...,1] += 2. * hopping * spacing * np.sin(_kmeshy*2*np.pi)[None,:,None]
    vk[...,2] += 2. * hopping * spacing * np.sin(_kmeshz*2*np.pi)[None,None,:]

    vk.resize(nkx*nky*nkz,1,3)
    ek.resize(nkx*nky*nkz,1)

    with h5py.File('HkdkFile_{}_{}_{}.hdf5'.format(nkx,nky,nkz),'w') as h5:
      h5['hk']    = ek
      h5['hkder'] = vk
